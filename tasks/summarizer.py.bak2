import os
import json
from openai import OpenAI
from youtube_transcript_api import YouTubeTranscriptApi
from dotenv import load_dotenv

# è¼‰å…¥ç’°å¢ƒè®Šæ•¸
load_dotenv()

PROMPT_TEMPLATE = """
ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„å½±ç‰‡å…§å®¹åˆ†æåŠ©æ‰‹ã€‚ä½ çš„ä»»å‹™æ˜¯åˆ†æ YouTube å½±ç‰‡é€å­—ç¨¿ï¼Œä¸¦æä¾›ç²¾ç…‰ä¸”æº–ç¢ºçš„ä¸­æ–‡æ‘˜è¦ã€‚

### âš ï¸ é‡è¦æŒ‡ä»¤ (CRITICAL INSTRUCTIONS):
1. **åƒ…é™é€å­—ç¨¿å…§å®¹**ï¼šä½ æä¾›çš„æ‰€æœ‰è³‡è¨Šã€å•é¡Œèˆ‡è§€é»ï¼Œå¿…é ˆã€Œå®Œå…¨ä¸”å”¯ä¸€ã€ä¾†è‡ªä¸‹æ–¹æä¾›çš„é€å­—ç¨¿å…§å®¹ã€‚
2. **ç¦æ­¢ç¯„ä¾‹å¹²æ“¾**ï¼šä¸‹æ–¹æä¾›çš„ç¯„ä¾‹åƒ…ç”¨æ–¼ã€Œæ ¼å¼åƒè€ƒã€ã€‚**åš´ç¦**å¼•ç”¨æˆ–åƒè€ƒç¯„ä¾‹ä¸­çš„ä»»ä½•å…·é«”å…§å®¹ã€æ¦‚å¿µã€äººåæˆ–å¤–éƒ¨æ¡ˆä¾‹ã€‚
3. **ç„¡æ•ˆè³‡è¨Šè™•ç†**ï¼šè‹¥é€å­—ç¨¿ä¸­æœªæåŠæŸå€‹ç¯„ä¾‹çµæ§‹æ‰€éœ€çš„æ™‚é–“é»æˆ–å…·é«”ç´°ç¯€ï¼Œè«‹çœç•¥è©²éƒ¨åˆ†ã€‚

### åŸ·è¡Œæ­¥é©Ÿï¼š
1. ä»”ç´°é–±è®€ä¸‹æ–¹é€å­—ç¨¿ï¼Œç¢ºä¿æŒæ¡å½±ç‰‡çš„æ ¸å¿ƒä¸»é¡Œèˆ‡é—œéµå°è©±ã€‚
2. è­˜åˆ¥å…§å®¹ä¸­çš„ä¸»è¦å•é¡Œèˆ‡è§€é»ï¼Œä¸¦é€²è¡Œé‚è¼¯åˆ†é¡ã€‚
3. æŒ‰ç…§æŒ‡å®šçš„ Markdown æ ¼å¼ç”Ÿæˆè¼¸å‡ºã€‚

### è¼¸å‡ºæ ¼å¼ç¯„ä¾‹ (åƒ…ä¾›æ ¼å¼åƒè€ƒ)ï¼š
## å…§å®¹æ‘˜è¦
[æ­¤è™•æ‡‰ç‚ºè©²å½±ç‰‡çš„æ·±å…¥æ‘˜è¦ï¼Œæ¶µè“‹èƒŒæ™¯ã€æ ¸å¿ƒè§€é»åŠè§£æ±ºæ–¹æ¡ˆ]

## ä¸»è¦å•é¡Œ
1. [é‡å°é€å­—ç¨¿æå‡ºçš„ç¬¬ä¸€å€‹é—œéµå•é¡Œ]
2. [é‡å°é€å­—ç¨¿æå‡ºçš„ç¬¬äºŒå€‹é—œéµå•é¡Œ]

## æœ‰æ¢ç†çš„å…§å®¹æ•´ç†
**[é¡åˆ¥ A]**
* [ç›¸é—œè§€é»æˆ–ç´°ç¯€]
* [ç›¸é—œè§€é»æˆ–ç´°ç¯€]

**[é¡åˆ¥ B]**
* [ç›¸é—œè§€é»æˆ–ç´°ç¯€]

## ç²¾ç…‰äº®é»
[ä»¥å‹•è©é–‹é ­ï¼Œæä¾›å…·é«”çš„è¡Œå‹•æŒ‡å¼•æˆ–èªçŸ¥æ”¹è®Š]

---
é€å­—ç¨¿å…§å®¹å¦‚ä¸‹ï¼š
{transcript}
"""


def get_transcript_text(video_id, save_to_file=False):
    """
    ç²å–é€å­—ç¨¿æ–‡å­—ã€‚
    :param video_id: YouTube Video ID
    :param save_to_file: æ˜¯å¦å„²å­˜ç‚º JSON æª”æ¡ˆ (transcripts/{video_id}.json)
    :return: é€å­—ç¨¿ç´”æ–‡å­— string or None
    """
    # 1. Check if local file exists
    transcript_dir = os.path.join(os.path.dirname(__file__), "..", "transcripts")
    os.makedirs(transcript_dir, exist_ok=True)
    file_path = os.path.join(transcript_dir, f"{video_id}.json")

    if os.path.exists(file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                if isinstance(data, list):
                    return " ".join([item.get('text', '') for item in data])
                elif isinstance(data, dict) and 'text' in data:
                    return data['text']
        except Exception as e:
            print(f"âš ï¸ è®€å–æœ¬åœ°é€å­—ç¨¿å¤±æ•— ({video_id}): {e}")

    try:
        yt_api = YouTubeTranscriptApi()
        transcript_obj = yt_api.fetch(video_id, languages=['zh-TW', 'zh', 'en'])
        
        if transcript_obj:
            if save_to_file:
                try:
                    serializable = []
                    for item in transcript_obj:
                        serializable.append({
                            'text': item.text if hasattr(item, 'text') else item.get('text'),
                            'start': item.start if hasattr(item, 'start') else item.get('start'),
                            'duration': item.duration if hasattr(item, 'duration') else item.get('duration')
                        })
                    
                    with open(file_path, "w", encoding="utf-8") as f:
                        json.dump(serializable, f, ensure_ascii=False, indent=2)
                        print(f"âœ… é€å­—ç¨¿å·²ç·©å­˜è‡³: {file_path}")
                except Exception as e:
                    print(f"âš ï¸ ç·©å­˜é€å­—ç¨¿å¤±æ•—: {e}")

            full_text = " ".join([snippet.text for snippet in transcript_obj])
            return full_text
        return None
    except Exception as e:
        print(f"âŒ å‚³çµ± API ç²å–é€å­—ç¨¿å¤±æ•— ({video_id}): {e}")
        print("ğŸ”„ å˜—è©¦ä½¿ç”¨ yt-dlp å‚™æ´æ©Ÿåˆ¶...")
        
        try:
            import yt_dlp
            
            url = f"https://www.youtube.com/watch?v={video_id}"
            ydl_opts = {
                'skip_download': True,
                'writeautomaticsub': True,
                'writesubtitles': True,
                'subtitleslangs': ['zh-TW', 'zh', 'en'],
                'quiet': True,
                'no_warnings': True,
            }
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                subtitles = info.get('subtitles', {}) or info.get('automatic_captions', {})
                lang_priority = ['zh-TW', 'zh-Hant', 'zh', 'zh-Hans', 'en']
                selected_lang = None
                
                for lang in lang_priority:
                     if lang in subtitles:
                         selected_lang = lang
                         break
                
                if not selected_lang and subtitles:
                    selected_lang = list(subtitles.keys())[0]
                    
                if selected_lang:
                    print(f"âœ… æ‰¾åˆ°å­—å¹•èªè¨€: {selected_lang}")
                    try:
                        temp_filename = f"temp_sub_{video_id}"
                        ydl_opts_download = {
                            'skip_download': True,
                            'writesubtitles': True,
                            'writeautomaticsub': True,
                            'subtitleslangs': [selected_lang],
                            'outtmpl': temp_filename,
                            'quiet': True,
                            'no_warnings': True,
                            'extractor_args': {'youtube': {'player_client': ['android']}},
                        }
                        
                        with yt_dlp.YoutubeDL(ydl_opts_download) as ydl_down:
                            ydl_down.download([url])
                        
                        expected_file = f"{temp_filename}.{selected_lang}.vtt"
                        if not os.path.exists(expected_file):
                             for f in os.listdir('.'):
                                 if f.startswith(temp_filename) and f.endswith('.vtt'):
                                     expected_file = f
                                     break
                        
                        if os.path.exists(expected_file):
                            with open(expected_file, 'r', encoding='utf-8') as f:
                                raw_content = f.read()
                            os.remove(expected_file)
                            lines = raw_content.splitlines()
                            text_lines = []
                            for line in lines:
                                if '-->' in line or line.strip() == 'WEBVTT' or not line.strip():
                                    continue
                                text_lines.append(line.strip())
                            unique_lines = []
                            last = ""
                            for line in text_lines:
                                if line != last:
                                    unique_lines.append(line)
                                    last = line
                                    
                            return " ".join(unique_lines)
                    except Exception as dl_err:
                        print(f"âŒ yt-dlp ä¸‹è¼‰æµç¨‹å¤±æ•—: {dl_err}")
        except Exception as yt_e:
            print(f"âŒ yt-dlp å‚™æ´å¤±æ•—: {yt_e}")
            return None

def summarize_video(video_id, video_title=""):
    print(f"ğŸ¤– æ­£åœ¨ç‚ºå½±ç‰‡ç”¢ç”Ÿæ‘˜è¦: {video_id} - {video_title}...")
    api_key = os.getenv("LLM_API_KEY")
    base_url = os.getenv("LLM_BASE_URL")
    model_name = os.getenv("LLM_MODEL", "gpt-4o")
    
    if not api_key or not base_url:
        print("âš ï¸ æœªè¨­å®š LLM_API_KEY æˆ– LLM_BASE_URLï¼Œè·³éæ‘˜è¦ç”Ÿæˆã€‚")
        return None

    transcript_text = get_transcript_text(video_id, save_to_file=True)
    if not transcript_text:
        return None
    
    if len(transcript_text) > 100000:
        print("âš ï¸ é€å­—ç¨¿éé•·ï¼Œé€²è¡Œæˆªæ–·...")
        transcript_text = transcript_text[:100000]

    try:
        client = OpenAI(api_key=api_key, base_url=base_url)
        response = client.chat.completions.create(
            model=model_name,
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": PROMPT_TEMPLATE.format(transcript=transcript_text)}
            ],
            temperature=0.7
        )
        summary = response.choices[0].message.content
        if summary.startswith("```markdown"):
            summary = summary.replace("```markdown", "", 1)
        if summary.startswith("```"):
            summary = summary.replace("```", "", 1)
        if summary.endswith("```"):
            summary = summary.rsplit("```", 1)[0]
        return summary.strip()
    except Exception as e:
        print(f"âŒç”Ÿæˆæ‘˜è¦æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        return None

def save_summary(video_id, content):
    filename = f"summary_{video_id}.md"
    with open(filename, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"âœ… æ‘˜è¦å·²å„²å­˜è‡³: {filename}")
